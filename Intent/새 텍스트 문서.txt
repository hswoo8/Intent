Intent는 일종의 메시지 객체
다른 앱 구성요소로부터 작업을 요청할 수 있습니다.

startActivity()로 Intent를 전달하면 새 인스턴스를 시작할수 있습니다.
액티비티가 완료되었을 때 결과를 수신하려면 startActivityForResult()를 호출합니다

Intent는 안드로이드 시스템이 어느 구성요소를 시작할지 판별하는데 사용하는 정보를 담고있습니다.
정확한 구성요소 이름 또는 인텐트를 수신해야 하는 구성 요소 카테고리 등 또한 수신자 구성요소가 작업을 
적절히 수행하기 위해 사용할 정보

구성 요소 이름, 작업, 데이터, 카테고리, 엑스트라, 플래그

구성요소 이름의 유무에 따라 명시적, 암시적 인텐트로 나뉜다.
Intent의 필드는 ComponentName 객체로, 대상 구성 요소의 정규화된 클래스 이름을 사용하여 지정할 수 있다
com.example.ExampleActivity 구성 요소 이름을 설정하려면 setComponent(), setClass() setClassName(), 생성자
를 사용합니다

작업 : 수행할 작업을 나타내는 문자열
ACTION_VIEW, ACTION_SEND
시스템의 설정앱에서 특정 화면을 여는 작업의 경우 Settings 를 확인
작업을 설정하려면 setAction(), 생성자 를 사용합니다
나름의 작업을 직접 정의하는 경우 앱의 패키지 이름을 접두어로 포함시켜야 합니다.
static final String ACTION_TIMETRAVEL = "com.yourapp.action.TIMETRAVEL";

데이터
	작업을 수행할 데이터 및 해당 데이터의 MIME 유형을 참조하는 URI입니다.
	인텐트를 생성할 때 URI외에도 데이터의 유형을 지정하는 것이 중요하다
	(ex. URI형식이 비슷한 두가지 기능의 경우 MIME유형을 지정해두면 인텐트를 수신할 최상의 구성요소
	를 찾는데 도움이 됩니다. 하지만 MIME 유형은 URI에서 추론되는 경우가 있습니다.)
	데이터가 content:URI 인경우 데이터가 기기에 위치하고 있고 ContentProvider가 제어한다는 것을 	
	나타내어 해당 데이터 MIME 유형이 시스템에 표시되도록 한다.
	데이터 URI를 설정하려면 setData(), MIME를 설정하려면 setType(), 동시 설정은 setDataAndType()
	(setData()와 setType()은 서로 값을 무효화 하므로 각각 쓰면 안된다)

카테고리
엑스트라
플래그
	Intent클래스에서 정의된 플래그로 인텐트에 대한 메타데이터
	안드로이드 시스템에 액티비티를 시작할 방법에 대한 지침을 줄 수 있고(ex. 어느 Task에 소속되어야)
	액티비티를 시작한 다음에 어떻게 처리해야 하는지 알려줄 수 있다.
	(ex. 최근 액티비티 목록에 소속되는지 여부)
	설정하려면 setFlags()
	
Task
	작업은 특정 작업을 수행 할 때 사용자가 상호 작용하는 액티비티의 모음입니다.
	액티비는 스택으로 배열됩니다. (ex. 이메일 앱에는 새 메시지 목록을 표시하는 액티비티가 있을 수 있다.
	사용자가 메시지를 선택하면 새 액티비티가 열리고 해당 메시지를 볼 수 있습니다. 사용자가 메시지를
	선택하면 새로운 액티비티가 열리고 해당 메시지를 볼 수 있습니다. 이 새로운 액티비티가 작업에 추가됩니다.)
	사용자가 뒤로가기를 누르면 새 활동이 완료되고 스택에서 제거 됩니다.

	홈 화면에서 아이콘을 실행하면 해당 앱의 작업이 포그라운드로 이동합니다. 앱에 대한 작업이 없으면
	새 작업이 만들어지고 해당 앱의 메인 액티비티가 작업의 루트 액티비티로 열리게 됩니다.

	현재 액티비티에서 다른 액티비티로 이동하면 새로운 액티비티는 스택 맨 위 푸시되고 포커스를 받습니다.
	이전 액티비티는 스택에 남아 있지만 중지됩니다. 사용자가 뒤로가기를 누르면 스택 상단의 액티비티가 팝업
	되고 이전활동이 재개됩니다. 스택의 액티비티는 결고 재배열되지 않으며 스택에서 푸시되고 팝만
	현재 액티비티에 의해 시작될 때 스택으로 푸시되고 사용자가 뒤로가면 튀어나와버립니다.
	작업(백 스택)은 마지막에서 처음으로 객체 구조로 작동합니다.

	작업은 사용자가 새로운 작업을 시작하거나 홈버튼을 통해 홈 화면으로 이동하면 배경으로 이동할
	수 있는 응집된 단위입니다. 백그라운드에서 작업 중 모든 작업이 중지되지만 작업의 백 스택은
	그대로 유지 됩니다. 작업은 포그라운드로 설정하여 사용자가 중단 한 부분을 선택할 수 있습니다.
	예를 들어 현재작업이 현재액티비티에서 이루어지다가 다른 앱을 키면 현재 앱은 백그라운드로 돌아가
	모든 액티비티를 중단시키고 다른 앱을 포그라운드로 포커스가 이동됩니다. 다시 이전 앱으로 돌아가려면
	최근 화면에서 앱의 작업을 선택하거나 앱 아이콘을 선택하면 됩니다. 

	
	백 스택의 액티비티는 결코 재배치되지 않기 때문에 앱이 사용자가 둘 이상의 액티비티에서 특정
	액티비티를 시작할 수 있게 하면 액티비티의 이전 인스턴스를 가져오는 대신 액티비티의 새 인스턴스가
	생성되어 스택으로 푸시됩니다.  따라서 하나의 액티비티가 여러번 인스턴스화 될 수 있습니다.
	사용자가 뒤로 버튼을 사용하면 인스턴스가 순서대로 팝됩니다. 그러나 액티비티를 2번 이상 인스턴스화
	하지 않으려면 동작을 수정할 수 있습니다.

	액티비티 A가 액티비티 B를 시작하면 A는 중단되지만 시스템은 상태를 보유합니다. 액티비티 B에서 사용자가
	뒤로가기를 누르면 액티비티 A는 상태가 복원된 상태에서 다시 시작됩니다.

	사용자가 홈단추를 눌러 작업을 떠날 때 현재 액티비티가 중지되고 해당 작업이 백그라운드로 이동합니다.
	시스템은 백스택의 모든 액티비티 상태를 유지합니다. 사용자가 나중에 작업을 시작한 실행기 아이콘을 선택하여
	작업을 다시 시작하면 작업은 포그라운드로 이동하여 스택 캔위에 있는 작업을 다시 시작합니다.
	
	사용자가 뒤로 버튼을 누르면 현재 액티비티가 스택에서 팝되어 파기됩니다. 스택의 이전 액티비티가
	재개됩니다. 액티비티가 파괴되면 시스템은 액티비티의 상태를 유지하지 않습니다.

테스크 관리
	
	기존의 액티비티를 가져올 수 있고 사용자가 떠날 때 루트를 제외한 모든 액티비티를 백스택에서 지우고 
	싶을 때도 있습니다.
	이와 관련하여 사용할 수 있는 주요 Activity 특성은 다음과 같습니다.
	
	taskAffinity
	launchMode
	allowTaskReparenting
	clearTaskOnLaunch
	alwaysRetainTaskState
	finishOnTaskLaunch
	
	Intent Flag FLAG_ACTIVITY_NEW_TASK, FLAG_ACTIVITY_CLEAR_TOP, FLAG_ACTIVITY_SINGLE_TOP

	메니페스트 특성 및 의도 플래그를 사용하여 작업과 작업의 연결 방법 및 백스택에서의 동작을 정의하는
	방법을 설명합니다.
	또한 별도로 논의되는 것은 작업 및 활동이 최근 화면에서 어떻게 표현되고 관려되는지에 대해 고려사항
	일반적으로 시스템이 테스크 및 활동이 최근 화면에서 어떻게 표시되는지 정의할수있어야 하며 동작을
	수정할 필요가 없습니다.?

	대부분의 앱이 액티비티 및 태스크의 기본 동작을 방해해서는 안된다. 액티비티가 기본동작을 수정하는데
	필요하다고 판단되면 실행 중에 주의해야하며 뒤로 버튼을 사용하여 다른 액티비티 및 태스크에서 다시 탐색해야
	합니다. 사용자의 예상되는 동작과 출동 할 수 있는 탐색 동작을 테스트 해야 합니다.

	시작 모드 정의

	실행모드에서는 액티비티의 새로운 인스턴스가 현재 태스크와 연관되는 방법을 정의할 수 있습니다.
	2가지 방법 Manifest 파일 사용, Intent Flag 사용

	따라서 액티비티 A가 B를 시작하면 B는 현재 태스크와 연관시키는 방법을 manifest에 정의할 수 있으며
	A는 B가 현재 태스크와 연결되는 방법을 요청할 수도 있습니다. 두 액티비티 모두 B가 Task와 연관시키는 것을 정의하면
	A의 요청은 B의 요청에 적용됩니다.

	매니페스트 파일에 사용할 수 있는 일부 실행모드는 인탠트 플래그로 사용할 수 없고 인탠트 플래그로 사용할 수 있는 실행모드는
	메니페스트에서 정의할 수 없습니다

	singleTop : 액티비티의 인스턴스가 이미 현재 태스크 맨위에 있으면 onNewIntent()를 호출합니다.
	새 인스턴스를 만들지 않고 해당 인서턴스로 라우트 합니다.
	액티비티는 여러번 인스턴스화 될수 있고 서로 다른 태스크에 속할 수 있으며 하나의 태스크는 여러 인스턴스를 가질 수 있습니다.

	(ex. B, C, D 액티비티가 있고 루트 A로 구성된다고 할 때 D에 Intent가 도착합니다. D에 기본 standard가 있으면
	새 인스턴스가 생성되고 ABCDD가 되고 singleTop이면 기존 스택으로 유지되고 onNewIntent만 호출합니다
	그러나 B의 활동에 인탠트가 도착하면 실행모드가 singletop임에도 불구하고 새인스턴스가 스택에 추가됩니다.

	singleTask 새 태스크를 작성하고 루트 활동을 인스턴스화합니다. 그러나 액티비티 인스턴스가 별도의 태스크에 존재하는경우
	시스템은 onNewIntent로 기존 인스턴스에 Intent를 라우트합니다 한번에 하나의 활동인스턴스만 존재 할 수 있습니다.

	singleInstance singleTask 시스템이 인스턴스를 보유하는 태스크로 다른 활동을 실행하지 않는다는 점을 제외하고 동일합니다.
	액티비티는 항상 그 작업의 단 하나의 유일한 인스턴스를 가집니다. 이작업으로 시작된 모든 액티비티는 별도의 작업으로 열립니다.

Affinity

	Intent.FLAG_ACTIVITY_NEW_TASK 를 이용하면 새로운 태스크에서 루트 액티비티가 생성된다고 생각하기 쉽다.
	하지만 affinity가 같다면 새로운 태스크로 열리기보다 같은 affinity의 태스크에서 인스턴스가 생성되고 푸쉬된다.
	affinity는 string값으로 설정하지 않으면 현재 액티비티의 패키지로 설정이 된다. 다른 패키지에서 액티비티를 생성하고 
	new_task 플래그를 더해주면 새로운 태스크로 액티비티가 열린다.
	참고로 같은 affinity라도 FLAG_ACTIVITY_MULTIPLE_TASK를 더해주면 무조건 새로운 Task에서 열린다.